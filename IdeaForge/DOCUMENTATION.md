# Idea Forge - Detailed Documentation (Fully Functional Version - Live AI with Simulated Build)

## 1. Introduction

### 1.1. Project Vision

Idea Forge aims to revolutionize mobile application development by enabling users to create Android applications through natural language prompts. This "fully functional" version takes a significant step by integrating a **live Large Language Model (Claude 3 Opus)** for real-time code generation, while using a **simulated build service** for the final APK delivery in this iteration. This allows for end-to-end testing of the core AI-driven development flow.

### 1.2. Version Goals

This version focuses on:

*   **Live AI Code Generation:** Demonstrating the capability of a state-of-the-art AI (Claude 3 Opus) to generate Flutter application code based on user prompts.
*   **End-to-End Workflow:** Testing the complete cycle from user prompt in the Android app, to the live backend, to the Claude API, receiving generated code, and then simulating the app build and APK delivery.
*   **Foundation for Real Builds:** Providing a backend structure that can be extended to integrate with a real cloud build service (e.g., Google Cloud Build) to compile the AI-generated code.
*   **User Experience with Live AI:** Allowing users to experience direct interaction with a powerful coding AI and see its output.

### 1.3. Scope of This Version

*   The **Idea Forge Android application** (client-side) built with Kotlin and Jetpack Compose.
*   A **chat-like interface** for user input.
*   Interaction with a **live AI backend** (`live_backend.py`) that uses the Claude 3 Opus API.
*   Real-time generation of Flutter (Dart) code by Claude.
*   Display of the AI-generated code within the Android app.
*   A **simulated build process** within the backend, which, after a delay, provides a download link to a **sample/placeholder Flutter APK**.

**Out of Scope for This Specific Iteration (but planned for future):**
*   Real-time cloud-based compilation of the *specific code generated by Claude in that session*.
*   Automated, AI-driven error correction and debugging of generated code (a placeholder function exists).
*   Advanced project management or on-device code editing.

## 2. System Architecture (In-Depth)

### 2.1. Idea Forge Android Application (Client)

This is the user-facing application installed on the Android device.

*   **UI Layer (Kotlin + Jetpack Compose):**
    *   `MainActivity.kt`: Main entry point.
    *   `ui/ChatScreen.kt`: Core composable for the chat interface. Manages message display (user, AI, system, code blocks) and input.
    *   `ui/theme/`: Theming files.
*   **ViewModel Layer (`viewmodel/ChatViewModel.kt`):**
    *   Manages UI state for `ChatScreen.kt`.
    *   Interacts with `LiveBackendClient.kt` to send prompts and receive responses (generated code, simulated APK links).
    *   Formats messages for display, including special rendering for code blocks.
*   **Network Layer (`network/LiveBackendClient.kt`):**
    *   Handles HTTP communication with the `live_backend.py` (running on port 5001 by default).
*   **Data Models (`ui/ChatScreen.kt` - Message data class):**
    *   `Message`: Represents chat messages, now includes an `isCodeBlock` flag for styling.

### 2.2. Live AI Backend (`IdeaForge_Backend/live_backend.py`)

This Python Flask application serves as the bridge between the Idea Forge app and the Claude AI, and also simulates the build process.

*   **Flask Application:** Lightweight web server.
*   **API Endpoint (`/api/v1/generate-app-live`):**
    *   Accepts POST requests with a JSON payload containing the user prompt.
*   **Claude API Integration:**
    *   Uses the `requests` library to call the Anthropic Messages API (`https://api.anthropic.com/v1/messages`).
    *   Authenticates using an API key loaded from an `.env` file (environment variable `ANTHROPIC_API_KEY`).
    *   Sends the user prompt along with a system prompt to guide Claude (targeting `claude-3-opus-20240229`).
    *   Manages a basic in-memory conversation history per user to provide context to Claude.
*   **Simulated Build Service Logic:**
    *   After receiving generated code from Claude, it **does not** compile this specific code.
    *   It introduces a random time delay (`time.sleep()`) to mimic a build duration.
    *   It then selects a URL from a predefined dictionary of sample APKs (`SAMPLE_APKS`) based on keywords in the original prompt.
    *   Returns the original AI-generated code *and* the link to the sample APK to the client.
*   **Configuration:**
    *   Listens on `0.0.0.0:5001`.
    *   Requires a `.env` file in the `IdeaForge_Backend` directory with the `ANTHROPIC_API_KEY`.

## 3. Live AI Interaction & Simulated Build Flow

1.  **User Prompt:** User types a request in the Idea Forge Android app.
2.  **To Backend:** The app sends the prompt to `live_backend.py` via `LiveBackendClient.kt`.
3.  **To Claude:** `live_backend.py` constructs a request (including conversation history and system prompt) and sends it to the Claude 3 Opus API.
4.  **Claude Generates Code:** Claude processes the request and returns the generated Flutter code.
5.  **Code Received by Backend:** `live_backend.py` receives the raw code text from Claude.
6.  **Backend Responds (Part 1 - Code):** The backend immediately sends a message back to the Android app indicating code generation was successful and includes the raw Flutter code generated by Claude. The `ChatViewModel` and `ChatScreen` display this code.
7.  **Simulated Build:** `live_backend.py` then enters the simulated build phase:
    *   Pauses for a random duration (e.g., 15-45 seconds).
    *   Selects a sample APK URL.
8.  **Backend Responds (Part 2 - APK Link):** After the simulated delay, the backend sends another message/updates the client with the link to the sample APK.
9.  **User Downloads Sample APK:** The user can click the link in the app to download the *sample* APK.

**Crucial Distinction:** The APK downloaded is a pre-existing sample, **not** an APK compiled from the code that Claude just generated in that session. The live part is the code generation itself.

## 4. Setup and Deployment (Local Testing)

Refer to the `README.md` in the `IdeaForge` project root for detailed step-by-step instructions on:
1.  Setting up and running the `live_backend.py` (Python, Flask, `.env` file for API key).
2.  Setting up and running the Idea Forge Android application in Android Studio.

**Key environment variable for the backend:**
*   `ANTHROPIC_API_KEY`: Must be set in `IdeaForge_Backend/.env`. Use the key you provided.

## 5. Future Development: Integrating Real Cloud Build (e.g., Google Cloud Build)

To transition from a simulated build to a real build of the AI-generated code:

1.  **Set up Google Cloud Build (User Task):**
    *   Create/select a GCP Project.
    *   Enable Cloud Build API, Cloud Storage API.
    *   Set up a source code repository (e.g., Google Cloud Source Repositories, GitHub) where the backend can push the AI-generated code.
    *   Create a `cloudbuild.yaml` file in this repository to define Flutter build steps (e.g., `flutter build apk`).
    *   Create a GCP Service Account with permissions for Cloud Build (trigger builds), Cloud Storage (write APKs), and the source repository.
    *   Download the JSON key for this Service Account.
2.  **Backend Modifications (Manus Task):**
    *   The `live_backend.py` will be updated.
    *   **Code Packaging:** After receiving code from Claude, parse it into appropriate file structures (e.g., `main.dart`, `pubspec.yaml`, etc.).
    *   **Push to Repository:** Programmatically commit and push these files to the designated Git repository.
    *   **Trigger Cloud Build:** Use the Google Cloud Build API (via Python client libraries and the Service Account JSON key) to trigger a new build based on the pushed code.
    *   **Monitor Build Status:** Poll the Cloud Build API for build completion or failure.
    *   **Retrieve APK Link:** If the build is successful, get the GCS URL of the compiled APK.
    *   **Return Real APK Link:** Send this URL back to the Idea Forge Android app.
3.  **Error Handling for Builds:** Implement logic to handle build failures, potentially relaying logs back to the user or attempting an AI-driven fix.

## 6. Developer and Extension Guide

*   **Modifying AI Prompts:** The `default_system_prompt` in `live_backend.py` can be tuned to change Claudeâ€™s behavior, code style, or focus.
*   **Changing AI Model:** The `CLAUDE_MODEL` variable in `live_backend.py` can be changed to other compatible Claude models (e.g., `claude-3-5-sonnet-20240620`) if needed, but ensure API compatibility.
*   **Adding Real Error Correction:** The `attempt_error_correction` function in `live_backend.py` is a placeholder. Implementing this would involve:
    *   Capturing build errors from a real build service.
    *   Constructing a new prompt for Claude that includes the erroneous code and the build errors, asking for a fix.
    *   Managing this iterative loop.

## 7. Troubleshooting

*   **Backend Connection Issues from App:** Verify `BASE_URL` in `LiveBackendClient.kt` (usually `http://10.0.2.2:5001` for emulator) and ensure `live_backend.py` is running on your computer and accessible on port `5001`.
*   **Claude API Errors:**
    *   Check that `ANTHROPIC_API_KEY` in `.env` is correct and has not expired/been revoked.
    *   Look for detailed error messages from the Claude API printed in the `live_backend.py` console.
    *   Ensure you have not hit API rate limits.
*   **Python Dependencies:** Ensure `Flask`, `requests`, and `python-dotenv` are installed in your Python environment for the backend.

This version provides a significant advancement by incorporating live AI code generation, setting a clear path towards a fully automated app creation tool.
